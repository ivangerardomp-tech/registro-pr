<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>Registro PR (KML + PRs del repo)</title>
  <link rel="manifest" href="manifest.json" />
  <meta name="theme-color" content="#0f172a" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon" href="icon-192.png">
  <style>
    :root { --bg:#0f172a; --card:#1e2537; --b:#334155; --text:#f8fafc; --muted:#94a3b8; --brand:#38bdf8; }
    * { box-sizing:border-box }
    body { background: var(--bg); color: var(--text); font-family: system-ui,-apple-system,Segoe UI,Roboto,sans-serif; padding:16px; max-width: 740px; margin:0 auto; }
    header { text-align:center; margin-bottom: 12px; }
    .card { background: var(--card); border:1px solid var(--b); border-radius:12px; padding:14px; margin-bottom:12px; }
    .row { display:flex; flex-direction:column; gap:8px }
    .row-h { display:flex; gap:8px; flex-wrap:wrap; align-items:center }
    .label { color:var(--muted); font-size:.75rem; text-transform:uppercase; letter-spacing:.05em }
    .value { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; white-space: pre-line }
    .hint { color:#64748b; font-size:.8rem }
    .warn { color:#fbbf24; font-size:.85rem }
    button { background: var(--brand); color:#0b1324; font-weight:700; padding:10px 12px; border-radius:10px; border:0; font-size:1rem; cursor:pointer }
    button:active { transform: scale(.98) }
    input.value, input[type=number] { width:100%; background: var(--bg); color: var(--text); border:1px solid var(--b); border-radius:8px; padding:10px; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
    #coords { white-space: pre-line }
    #videoWrap { position:relative; width:100%; border-radius:12px; overflow:hidden; border:1px solid var(--b); background:#000; display:none; }
    video { width:100%; height:auto; }
    #overlay { position:absolute; left:0; right:0; bottom:0; background: rgba(0,0,0,.55); color:#fff; padding:8px 10px; font-family: ui-monospace, Menlo; font-size:.85rem; line-height:1.2rem }
    #topBadge { position:absolute; top:8px; left:8px; background: rgba(15,23,42,.7); color:#fff; padding:6px 10px; border-radius:999px; font-size:.75rem; border:1px solid rgba(255,255,255,.15) }
    #previewImg { width:100%; max-height: 260px; object-fit:contain; display:none; border:1px solid var(--b); border-radius:8px }
    .hidden { display:none !important }
    .ok { color:#22c55e }
    .bad { color:#ef4444 }
    .pill { padding:4px 8px; border:1px solid var(--b); border-radius:999px; font-size:.8rem; background:#0b1324 }
  </style>
</head>
<body>
  <header>
    <h2>Registro PR</h2>
    <div class="hint">Lee <b>PRs.csv</b> del repositorio y descarga el <b>TRAMO.kml</b> por selección. Si no calcula, refresca fuerte (Ctrl+F5) o borra datos del sitio para actualizar la caché.</div>
  </header>

  <section class="card">
    <div class="row">
      <div class="label">1) Seleccionar TRAMO (KML del repo)</div>
      <div class="row-h">
        <select id="tramoSelect"><option value="">— Selecciona —</option></select>
        <button id="btnLoadKML">Cargar KML</button>
        <span id="tramoBadge" class="pill hidden"></span>
      </div>
      <div id="kmlStatus" class="value">Sin ruta.</div>
      <div class="hint">Los archivos KML deben llamarse exactamente como el TRAMO, p.ej.: <b>4505.kml</b>, <b>45HLC.kml</b>. Si los tienes en subcarpeta, ajusta <code>KML_BASE</code>.</div>
    </div>
  </section>

  <section class="card">
    <div class="row">
      <div class="label">2) PRs.csv del repositorio</div>
      <div class="row-h">
        <button id="btnLoadRepoPRS">Cargar PRs del repo</button>
        <span id="prsBadge" class="pill hidden"></span>
      </div>
      <div id="prsStatus" class="value">Intentando leer PRs.csv…</div>
      <div id="prsDebug" class="value" style="font-size:.8rem; color:#9ca3af">—</div>
      <div class="hint">Debe existir <b>PRs.csv</b> junto a este <code>index.html</code>.</div>
    </div>
  </section>

  <section class="card">
    <div class="row">
      <div class="label">3) GPS en vivo</div>
      <div id="state" class="value">Cargando…</div>
      <div id="coords" class="value">lat: —, lon: —
precisión: — m
velocidad: — m/s</div>
      <button id="btnEnableGPS" class="hidden">Activar GPS</button>
      <div class="hint">Requiere HTTPS y permisos de ubicación.</div>
    </div>
  </section>

  <section class="card">
    <div class="row">
      <div class="label">4) Entrar coordenadas manuales (opcional)</div>
      <div class="row-h">
        <input id="latIn" class="value" placeholder="lat" />
        <input id="lonIn" class="value" placeholder="lon" />
        <input id="offsetm" type="number" step="1" value="0" class="value" placeholder="offset PR (m)" />
        <button id="btnCalc">Calcular</button>
      </div>
    </div>
  </section>

  <section class="card">
    <div class="row">
      <div class="label">Resultados</div>
      <div id="result" class="value">—</div>
    </div>
  </section>

  <section class="card">
    <div class="row">
      <div class="label">Cámara</div>
      <div id="videoWrap">
        <div id="topBadge">Cámara activa</div>
        <video id="video" autoplay playsinline muted></video>
        <div id="overlay">
          <span id="coordsLine"></span><br>
          <span id="speedPRLine"></span>
        </div>
      </div>
      <div class="row-h">
        <button id="btnOpenCam">Abrir cámara</button>
        <button id="btnSnap" disabled>Capturar foto</button>
      </div>
      <div id="iosFallback" class="hidden">
        <div class="warn">iOS PWA: usa el selector del sistema</div>
        <input id="fileInput" type="file" accept="image/*" capture="environment" />
      </div>
      <img id="previewImg" alt="captura" />
    </div>
  </section>

  <section class="card">
    <div class="row">
      <div class="label">Nombre PR</div>
      <input id="prField" class="value" placeholder="PR_000+000" />
      <div class="row-h">
        <button id="btnDownload" disabled>Descargar JPG</button>
        <button id="btnShare" disabled>Compartir / Guardar en Fotos</button>
        <button id="btnReset">Reiniciar</button>
      </div>
    </div>
  </section>

  <section class="card">
    <div class="row">
      <div class="label">Log</div>
      <div id="log" class="value" style="white-space:pre-line">Listo.</div>
    </div>
  </section>

<script>
const R = 6371000;
const isHttps = location.protocol === 'https:' || location.hostname === 'localhost';
const KML_BASE = './'; // cambia a './kml/' si tus KML están en subcarpeta

function toRad(d){ return d * Math.PI / 180; }
function haversine(lat1, lon1, lat2, lon2){
  const dLat = toRad(lat2-lat1), dLon = toRad(lon2-lon1);
  const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
  return 2 * R * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
}
function makeLocalProjector(lat0, lon0){
  const cos0 = Math.cos(toRad(lat0));
  return {
    toXY(lat, lon){ return [ R * toRad(lon - lon0) * cos0, R * toRad(lat - lat0) ]; },
    toLL(x, y){ return [ (y / R) * 180/Math.PI + lat0, (x / (R * cos0)) * 180/Math.PI + lon0 ]; }
  }
}
function cumulativeGeodesic(pointsLL){
  const n = pointsLL.length, cum = new Float64Array(n); let acc = 0;
  for (let i=0;i<n-1;i++){ const [aLat,aLon]=pointsLL[i], [bLat,bLon]=pointsLL[i+1]; acc += haversine(aLat,aLon,bLat,bLon); cum[i+1]=acc; }
  return cum;
}
function debug(msg){ console.log(msg); document.getElementById('prsDebug').textContent = msg; }
function log(msg){ console.log(msg); document.getElementById('log').textContent = msg; }
function numOrNaN(x){
  if (x==null) return NaN;
  let s = String(x).trim().replace(",", ".");
  if (s==="") return NaN;
  const v = Number(s);
  return Number.isFinite(v) ? v : NaN;
}

// CSV robusto
function parseCSVsmart(text){
  const sep = text.indexOf('\t')>-1 ? '\t' : (text.indexOf(';')>-1 && text.indexOf(',')>-1 ? ',' : (text.indexOf(';')>-1 ? ';' : ','));
  const delimiter = sep==='\t' ? '\t' : sep;
  const rows=[]; let i=0, cur='', inQ=false, row=[];
  const pushRow=()=>{ if (row.length) rows.push(row); row=[]; };
  while(i<text.length){
    const ch=text[i];
    if (inQ){
      if (ch === '"'){ if (text[i+1] === '"'){ cur+='"'; i+=2; continue; } inQ=false; i++; continue; }
      cur+=ch; i++; continue;
    } else {
      if (ch === '"'){ inQ=true; i++; continue; }
      if ((delimiter==='\t' && ch==='\t') || ch===delimiter){ row.push(cur); cur=''; i++; continue; }
      if (ch === '\n'){ row.push(cur); cur=''; pushRow(); i++; continue; }
      if (ch === '\r'){ i++; continue; }
      cur += ch; i++;
    }
  }
  if (cur.length || row.length){ row.push(cur); pushRow(); }
  if (!rows.length) return { header:[], rows:[] };
  const header = rows.shift().map(h => String(h||'').replace(/^\ufeff/,'').trim());
  return { header, rows };
}
function normalizeHeaders(header){
  const map = new Map();
  header.forEach((h,idx)=>{ const key = String(h).toUpperCase().replace(/\s+/g,''); map.set(key, idx); });
  return map;
}

let locator = null;
let tramoActual = null;
let prsIndex = new Map();
let lastCoords = null, watchId = null;

async function loadPRsFromRepo(){
  try{
    const r = await fetch('./PRs.csv?v=' + Date.now(), { cache: 'no-store' });
    if (!r.ok) throw new Error('HTTP ' + r.status);
    const text = await r.text();
    const { header, rows } = parseCSVsmart(text);
    const H = normalizeHeaders(header);
    const idxTramo = H.get('TRAMO') ?? H.get('IDTRAMO') ?? H.get('CODIGOTRAMO');
    const idxPR = H.get('PR');
    const idxDist = H.get('DISTANCIA') ?? H.get('KM') ?? H.get('CADENAJE') ?? H.get('PROGRESIVA');
    debug('Encabezados: ' + header.join(' | '));
    if (idxTramo==null || idxPR==null || idxDist==null) throw new Error('No se hallaron TRAMO/PR/DISTANCIA');
    const byTramo = new Map();
    for (const r of rows){
      const tramo = String(r[idxTramo] ?? '').trim().toUpperCase();
      const pr = String(r[idxPR] ?? '').trim();
      const dist = numOrNaN(r[idxDist]);
      if (!tramo || !pr || !Number.isFinite(dist)) continue;
      if (!byTramo.has(tramo)) byTramo.set(tramo, []);
      byTramo.get(tramo).push({ d:dist, pr });
    }
    prsIndex = new Map();
    const tramoList = [];
    for (const [tramo, arr] of byTramo){
      arr.sort((a,b)=>a.d-b.d);
      prsIndex.set(tramo, { dist: Float64Array.from(arr.map(o=>o.d)), pr: arr.map(o=>o.pr) });
      tramoList.push(tramo);
    }
    tramoList.sort((a,b)=>a.localeCompare(b,'es'));
    const sel = document.getElementById('tramoSelect');
    sel.innerHTML = '<option value="">— Selecciona —</option>' + tramoList.map(t=>`<option value="${t}">${t}</option>`).join('');
    document.getElementById('prsStatus').innerHTML = `<span class="ok">PRs.csv cargado.</span> Tramos: ${prsIndex.size}`;
    const badge = document.getElementById('prsBadge'); badge.textContent='PRs OK'; badge.classList.remove('hidden');
    if (locator && lastCoords){ const res = distanceFromOrigin(lastCoords.latitude, lastCoords.longitude, locator); renderResult(res); }
  }catch(e){
    document.getElementById('prsStatus').innerHTML = '<span class="bad">No se pudo leer PRs.csv: '+ e.message +'</span>';
  }
}
document.getElementById('btnLoadRepoPRS').addEventListener('click', loadPRsFromRepo);
loadPRsFromRepo();

async function fetchKMLAsLatLon(url){
  const r = await fetch(url, { cache: 'no-store' });
  if (!r.ok) throw new Error('HTTP '+r.status);
  const text = await r.text();
  const xml = new DOMParser().parseFromString(text, 'application/xml');
  const nodes = Array.from(xml.getElementsByTagName('coordinates'));
  let lonlat = [];
  for (const n of nodes){
    const t=(n.textContent||'').trim(); if(!t) continue;
    const toks=t.replace(/\s+/g,' ').split(' ').filter(Boolean);
    for (const tk of toks){ const p=tk.split(','); if(p.length>=2) lonlat.push([parseFloat(p[0]), parseFloat(p[1])]); }
  }
  const gx='http://www.google.com/kml/ext/2.2';
  const tags=xml.getElementsByTagNameNS(gx,'coord');
  for (const n of tags){
    const t=(n.textContent||'').trim(); if(!t) continue;
    const p=t.split(/[\s,]+/).filter(Boolean);
    if (p.length>=2) lonlat.push([parseFloat(p[0]), parseFloat(p[1])]);
  }
  if (!lonlat.length) throw new Error('KML sin geometría de línea.');
  const merged=[]; let last0=null,last1=null;
  for (const [lon,lat] of lonlat){ if(last0===lon && last1===lat) continue; merged.push([lat,lon]); last0=lon; last1=lat; }
  if (merged.length<2) throw new Error('Ruta con menos de 2 vértices.');
  return merged;
}
function buildLocator(densePoints){
  const [lat0, lon0] = densePoints[0];
  const proj = makeLocalProjector(lat0, lon0);
  const XY = densePoints.map(([lat,lon]) => proj.toXY(lat,lon));
  const cum = cumulativeGeodesic(densePoints);
  return { proj, XY, LL: densePoints, cum };
}
function distanceFromOrigin(lat, lon, loc){
  const { proj, XY, LL, cum } = loc;
  const [px, py] = proj.toXY(lat, lon);
  let bestK=0, bestD2=Infinity;
  for (let k=0;k<XY.length;k++){ const [x,y]=XY[k]; const dx=x-px, dy=y-py; const d2=dx*dx+dy*dy; if (d2<bestD2){bestD2=d2; bestK=k;} }
  const cands=[]; if (bestK>0) cands.push([bestK-1,bestK]); if (bestK<XY.length-1) cands.push([bestK,bestK+1]);
  let best=null, bestSegD2=Infinity;
  for (const [i0,i1] of cands){
    const A=XY[i0], B=XY[i1]; const ABx=B[0]-A[0], ABy=B[1]-A[1]; const AB2=ABx*ABx+ABy*ABy; if (AB2===0) continue;
    const APx=px-A[0], APy=py-A[1]; const t=Math.max(0,Math.min(1,(APx*ABx+APy*ABy)/AB2));
    const projx=A[0]+t*ABx, projy=A[1]+t*ABy; const dx=projx-px, dy=projy-py; const d2=dx*dx+dy*dy;
    if (d2<bestSegD2){ bestSegD2=d2; best={i0,i1,t,projxy:[projx,projy]}; }
  }
  const [projLat, projLon] = loc.proj.toLL(best.projxy[0], best.projxy[1]);
  const dToRoute = haversine(lat, lon, projLat, projLon);
  const i0=best.i0; const partial = haversine(LL[i0][0], LL[i0][1], projLat, projLon);
  const distFromOrigin = cum[i0] + partial;
  return { distance_from_origin_m: distFromOrigin, distance_to_route_m: dToRoute, nearest_latlon:[projLat,projLon], segment_index:i0 };
}
function buscarPRPorDist(tramo, objetivoM){
  const reg = prsIndex.get(tramo);
  if (!reg) return null;
  const d=reg.dist, p=reg.pr; let lo=0, hi=d.length;
  while (lo<hi){ const m=(lo+hi)>>1; if (d[m]<=objetivoM) lo=m+1; else hi=m; }
  const pos=lo-1; if (pos<0) return null;
  return { basePR: p[pos], metros: Math.round(objetivoM - d[pos]) };
}
function renderResult(res){
  const resultEl = document.getElementById('result');
  const overlay = document.getElementById('overlay');
  if (!res){ resultEl.textContent = '—'; return; }
  const dBase = res.distance_from_origin_m;
  const offset = Number(document.getElementById('offsetm').value||0);
  const objetivo = dBase + (Number.isFinite(offset)? offset : 0);
  let prTxt = '—';
  if (tramoActual && prsIndex.has(tramoActual)){
    const it = buscarPRPorDist(tramoActual, objetivo);
    if (it){
      const mm = String(Math.max(0, it.metros)).padStart(3,'0');
      prTxt = `${String(it.basePR).replace(/\s+/g,'')}+${mm}`;
      if (!document.getElementById('prField').value) document.getElementById('prField').value = `PR_${prTxt}`;
    } else {
      prTxt = 'Sin PR para esa distancia';
    }
  } else {
    prTxt = 'Falta PRs.csv o TRAMO.';
  }
  const dRoute = res.distance_to_route_m;
  const [nlat,nlon] = res.nearest_latlon;
  resultEl.textContent =
`dist_origen: ${dBase.toFixed(2)} m
dist_a_ruta: ${dRoute.toFixed(2)} m
pie: lat ${nlat.toFixed(6)}, lon ${nlon.toFixed(6)}
segmento: ${res.segment_index}
TRAMO: ${tramoActual ?? '—'}
PR: ${prTxt}`;
  if (lastCoords){
    const lat = lastCoords.latitude.toFixed(6);
    const lon = lastCoords.longitude.toFixed(6);
    const acc = (lastCoords.accuracy ?? NaN).toFixed(1);
    const vel = lastCoords.speed; const velFmt = (isFinite(vel)? vel.toFixed(2) : '—');
    overlay.textContent = `lat: ${lat}, lon: ${lon} | precisión: ${acc} m | vel: ${velFmt} m/s | TRAMO: ${tramoActual ?? '—'} | PR: ${prTxt}`;
  }
}

document.getElementById('btnLoadKML').addEventListener('click', async () => {
  const tramo = document.getElementById('tramoSelect').value.trim().toUpperCase();
  if (!tramo){ document.getElementById('kmlStatus').innerHTML = '<span class="bad">Selecciona un TRAMO.</span>'; return; }
  try{
    const url = KML_BASE + encodeURIComponent(tramo) + '.kml';
    const pts = await fetchKMLAsLatLon(url);
    locator = buildLocator(pts);
    tramoActual = tramo;
    document.getElementById('kmlStatus').innerHTML = `<span class="ok">Ruta cargada:</span> ${pts.length} vértices.`;
    const tb = document.getElementById('tramoBadge'); tb.textContent = 'TRAMO: ' + tramo; tb.classList.remove('hidden');
    if (lastCoords){ const res = distanceFromOrigin(lastCoords.latitude, lastCoords.longitude, locator); renderResult(res); }
  }catch(e){
    document.getElementById('kmlStatus').innerHTML = '<span class="bad">Error KML: '+ e.message +'</span>';
  }
});
document.getElementById('btnCalc').addEventListener('click', () => {
  if (!locator){ document.getElementById('result').textContent = 'Cargue primero un KML.'; return; }
  const lat = Number(document.getElementById('latIn').value), lon = Number(document.getElementById('lonIn').value);
  if (!isFinite(lat) || !isFinite(lon)){ document.getElementById('result').textContent = 'Lat/lon inválidos.'; return; }
  const res = distanceFromOrigin(lat, lon, locator);
  renderResult(res);
});
document.getElementById('btnReset').addEventListener('click', () => location.reload());

function startWatchPosition(){
  const stateEl = document.getElementById('state');
  if (!isHttps){ stateEl.textContent = 'GPS requiere HTTPS (usa GitHub Pages).'; return; }
  if (!navigator.geolocation) { stateEl.textContent = 'Geolocalización no soportada.'; return; }
  try {
    if (watchId !== null) navigator.geolocation.clearWatch(watchId);
    watchId = navigator.geolocation.watchPosition((pos) => {
      const { latitude, longitude, accuracy, speed } = pos.coords;
      lastCoords = { latitude, longitude, accuracy, speed };
      const lat = latitude?.toFixed(6);
      const lon = longitude?.toFixed(6);
      const acc = (accuracy ?? NaN).toFixed(1);
      const vel = (speed ?? 0);
      const velFmt = (isFinite(vel) ? vel.toFixed(2) : '—');
      document.getElementById('coords').textContent = `lat: ${lat}, lon: ${lon}
precisión: ${acc} m
velocidad: ${velFmt} m/s`;
      if (locator){
        const res = distanceFromOrigin(latitude, longitude, locator);
        renderResult(res);
      }
      stateEl.textContent = 'GPS activo (watchPosition).';
    }, (err) => {
      stateEl.textContent = 'Error GPS: ' + err.message;
      document.getElementById('btnEnableGPS').classList.remove('hidden');
    }, { enableHighAccuracy: true, timeout: 20000, maximumAge: 0 });
  } catch(e){
    stateEl.textContent = 'Excepción GPS: ' + e.message;
    document.getElementById('btnEnableGPS').classList.remove('hidden');
  }
}
startWatchPosition();
document.getElementById('btnEnableGPS').addEventListener('click', () => {
  navigator.geolocation.getCurrentPosition(
    () => { document.getElementById('btnEnableGPS').classList.add('hidden'); startWatchPosition(); },
    (err) => { document.getElementById('state').textContent = 'GPS denegado: ' + err.message; },
    { enableHighAccuracy: true, timeout: 15000, maximumAge: 0 }
  );
});

const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
const isStandalone = window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone;

async function openCameraStream(){
  const videoWrap = document.getElementById('videoWrap');
  const btnSnap = document.getElementById('btnSnap');
  const stateEl = document.getElementById('state');
  const iosFallback = document.getElementById('iosFallback');
  const videoEl = document.getElementById('video');
  const coordsLine = document.getElementById('coordsLine');
  const speedPRLine = document.getElementById('speedPRLine');

  // Comprobamos si el navegador soporta getUserMedia
  if (!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia)){
    if (isIOS){ iosFallback.classList.remove('hidden'); stateEl.textContent = 'Cámara no disponible en PWA iOS: usa selector.'; }
    else { stateEl.textContent = 'Cámara no soportada en este navegador.'; }
    return;
  }

  // Si es posible acceder a la cámara, configuramos el stream
  try {
    const constraints = { video: { facingMode: { ideal: 'environment' } }, audio: false };
    const stream = await navigator.mediaDevices.getUserMedia(constraints);
    videoEl.srcObject = stream;
    videoWrap.style.display = 'block';
    btnSnap.disabled = false;
    stateEl.textContent = 'Cámara en vivo activa.';

    // Cada vez que el video se actualice, también se actualizarán las coordenadas y otros datos
    stream.getTracks().forEach(track => {
      track.onended = () => {
        stateEl.textContent = 'Cámara detenida';
      };
    });

    // Aquí es donde actualizamos las dos líneas de información
    const updateOverlay = () => {
      if (lastCoords) {
        const lat = lastCoords.latitude.toFixed(6);
        const lon = lastCoords.longitude.toFixed(6);
        const acc = (lastCoords.accuracy ?? NaN).toFixed(1);
        const vel = (lastCoords.speed ?? 0);
        const velFmt = (isFinite(vel) ? vel.toFixed(2) : '—');

        // Actualizamos la primera línea con lat, lon y precisión
        coordsLine.textContent = `lat: ${lat}, lon: ${lon} | precisión: ${acc} m`;

        // Aquí vamos a buscar el PR usando la distancia desde el origen
        let prTxt = 'PR: —';
        if (tramoActual && prsIndex.has(tramoActual)) {
          const distFromOrigin = cumulativeGeodesic(locator.cum); // Usamos la distancia acumulada
          const prData = buscarPRPorDist(tramoActual, distFromOrigin); // Calculamos PR por distancia

          if (prData) {
            prTxt = `PR: ${prData.basePR} + ${prData.metros}`;
          }
        }

        // Actualizamos la segunda línea con velocidad, TRAMO y PR
        speedPRLine.textContent = `vel: ${velFmt} m/s | TRAMO: ${tramoActual ?? '—'} | ${prTxt}`;
      }
    };

    // Actualizar la información cada segundo mientras la cámara está activa
    const overlayInterval = setInterval(updateOverlay, 1000);
    
    // Limpiar intervalos cuando se detiene el stream
    stream.oninactive = () => clearInterval(overlayInterval);
  } catch (e) {
    if (isIOS && isStandalone){
      iosFallback.classList.remove('hidden');
      stateEl.textContent = 'iOS (PWA): permiso de cámara denegado o no soportado. Usa selector.';
    } else {
      stateEl.textContent = 'No se pudo abrir la cámara: ' + e.message;
    }
  }
}


// Llamar a esta función cuando se haga clic en "Abrir cámara"
document.getElementById('btnOpenCam').addEventListener('click', openCameraStream);

document.getElementById('btnSnap').addEventListener('click', () => {
  const videoEl = document.getElementById('video');
  const previewImg = document.getElementById('previewImg');
  const prField = document.getElementById('prField');
  const btnDownload = document.getElementById('btnDownload');
  const btnShare = document.getElementById('btnShare');
  if (!videoEl.videoWidth) { log('Video no listo'); return; }
  const canvas = document.createElement('canvas');
  canvas.width = videoEl.videoWidth;
  canvas.height = videoEl.videoHeight;
  const ctx = canvas.getContext('2d');
  ctx.drawImage(videoEl, 0, 0);
  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  const barH = Math.round(canvas.height * 0.07);
  ctx.fillRect(0, canvas.height - barH, canvas.width, barH);
  ctx.fillStyle = '#fff';
  const fontSize = Math.max(18, Math.round(canvas.width * 0.03));
  ctx.font = `${fontSize}px ui-monospace, Menlo, monospace`;
  ctx.fillText(document.getElementById('overlay').textContent, Math.round(canvas.width*0.02), canvas.height - Math.round(barH*0.35));
  canvas.toBlob((blob) => {
    const url = URL.createObjectURL(blob);
    previewImg.src = url;
    previewImg.style.display = 'block';
    btnDownload.disabled = false;
    const name = (prField.value || 'PR_sin_nombre').trim() + '.jpg';
    const fileObj = new File([blob], name, { type:'image/jpeg' });
    btnShare.disabled = !(navigator.canShare && navigator.canShare({ files: [fileObj] }));
    btnShare.onclick = async () => { try { await navigator.share({ files: [fileObj] }, { title: name, text: 'Captura PR' }); } catch {} };
    btnDownload.onclick = () => { const a = document.createElement('a'); a.href = url; a.download = name; a.click(); URL.revokeObjectURL(url); };
  }, 'image/jpeg', 0.92);
});

document.getElementById('fileInput').addEventListener('change', (e) => {
  const f = e.target.files?.[0];
  if (!f) return;
  const url = URL.createObjectURL(f);
  const img = new Image();
  img.onload = () => {
    const canvas = document.createElement('canvas');
    canvas.width = img.naturalWidth;
    canvas.height = img.naturalHeight;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(img, 0, 0);
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    const barH = Math.round(canvas.height * 0.07);
    ctx.fillRect(0, canvas.height - barH, canvas.width, barH);
    ctx.fillStyle = '#fff';
    const fontSize = Math.max(18, Math.round(canvas.width * 0.03));
    ctx.font = `${fontSize}px ui-monospace, Menlo, monospace`;
    ctx.fillText(document.getElementById('overlay').textContent, Math.round(canvas.width*0.02), canvas.height - Math.round(barH*0.35));
    canvas.toBlob((blob) => {
      const out = URL.createObjectURL(blob);
      document.getElementById('previewImg').src = out;
      document.getElementById('previewImg').style.display = 'block';
      document.getElementById('btnDownload').disabled = false;
    }, 'image/jpeg', 0.92);
    URL.revokeObjectURL(url);
  };
  img.src = url;
});

if ('serviceWorker' in navigator) { navigator.serviceWorker.register('./service-worker.js').catch(()=>{}); }
</script>
</body>
</html>
